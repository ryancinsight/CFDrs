//! # SlotMap-Backed Storage Pools
//!
//! These types provide the storage layer for [`crate::domain::mesh::HalfEdgeMesh`].
//! Unlike the legacy [`super::Pool`] (a plain `Vec<T>`) or
//! [`super::VertexPool`] (a `Vec` + spatial hash), these pools use
//! [`slotmap::SlotMap`] to guarantee:
//!
//! - **Generational safety** — stale keys return `None`, never silently alias
//!   a newly-allocated slot.
//! - **O(1) keyed access** — insertion, removal, and lookup are all O(1).
//! - **Zero-cost with GhostCell** — wrapping values in
//!   [`GhostCell<'id, T>`][crate::infrastructure::permission::GhostCell] costs no memory or
//!   runtime overhead beyond the `UnsafeCell` that `GhostCell` wraps.
//!
//! ## Diagram
//!
//! ```text
//! SlotPool<VertexKey, VertexData>
//!   ┌──────────────────────────────────┐
//!   │  SlotMap<VertexKey, VertexData>  │
//!   │  ┌─────┬──────────────────────┐  │
//!   │  │ gen │ VertexData / vacant  │  │  ← generation counter prevents
//!   │  ├─────┼──────────────────────┤  │    stale-key aliasing
//!   │  │ gen │ VertexData / vacant  │  │
//!   │  └─────┴──────────────────────┘  │
//!   └──────────────────────────────────┘
//! ```
//!
//! ## GhostCell variant
//!
//! For the half-edge mesh, all slot values are wrapped in
//! `GhostCell<'id, T>`.  The [`GhostSlotPool`] type alias captures this
//! pattern:
//!
//! ```text
//! GhostSlotPool<'id, VertexKey, VertexData>
//!   = SlotPool<VertexKey, GhostCell<'id, VertexData>>
//! ```
//!
//! Reading a value requires `&GhostToken<'id>`; writing requires
//! `&mut GhostToken<'id>`.  This ensures that all mutable borrows within
//! one call to [`crate::domain::mesh::with_mesh`] are serialized through the token.

use crate::infrastructure::permission::GhostCell;
use slotmap::{Key, SlotMap};

// ── SlotPool ──────────────────────────────────────────────────────────────────

/// A thin wrapper around [`SlotMap<K, V>`] that adds convenience methods
/// matching the interface of the legacy [`super::Pool`].
///
/// `K` must be a [`slotmap::Key`] (generated by `new_key_type!`).
pub struct SlotPool<K: Key, V> {
    inner: SlotMap<K, V>,
}

impl<K: Key, V> SlotPool<K, V> {
    /// Create an empty pool.
    pub fn new() -> Self {
        Self {
            inner: SlotMap::with_key(),
        }
    }

    /// Create with a pre-allocated capacity.
    pub fn with_capacity(cap: usize) -> Self {
        Self {
            inner: SlotMap::with_capacity_and_key(cap),
        }
    }

    /// Insert a value, returning its key.
    #[inline]
    pub fn insert(&mut self, value: V) -> K {
        self.inner.insert(value)
    }

    /// Remove the value at `key`, returning it if the key was valid.
    #[inline]
    pub fn remove(&mut self, key: K) -> Option<V> {
        self.inner.remove(key)
    }

    /// Get a shared reference.  Returns `None` for stale keys.
    #[inline]
    pub fn get(&self, key: K) -> Option<&V> {
        self.inner.get(key)
    }

    /// Get a mutable reference.  Returns `None` for stale keys.
    #[inline]
    pub fn get_mut(&mut self, key: K) -> Option<&mut V> {
        self.inner.get_mut(key)
    }

    /// Returns `true` if `key` is live.
    #[inline]
    pub fn contains_key(&self, key: K) -> bool {
        self.inner.contains_key(key)
    }

    /// Number of live slots.
    #[inline]
    pub fn len(&self) -> usize {
        self.inner.len()
    }

    /// Returns `true` if empty.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }

    /// Iterator over all live `(key, value)` pairs.
    #[inline]
    pub fn iter(&self) -> impl Iterator<Item = (K, &V)> {
        self.inner.iter()
    }

    /// Mutable iterator over all live `(key, value)` pairs.
    #[inline]
    pub fn iter_mut(&mut self) -> impl Iterator<Item = (K, &mut V)> {
        self.inner.iter_mut()
    }

    /// Iterator over all live keys.
    #[inline]
    pub fn keys(&self) -> impl Iterator<Item = K> + '_ {
        self.inner.keys()
    }

    /// Iterator over all live values.
    #[inline]
    pub fn values(&self) -> impl Iterator<Item = &V> {
        self.inner.values()
    }

    /// Clear all slots.
    pub fn clear(&mut self) {
        self.inner.clear();
    }

    /// Provide access to the underlying [`SlotMap`].
    #[inline]
    pub fn as_slotmap(&self) -> &SlotMap<K, V> {
        &self.inner
    }

    /// Provide mutable access to the underlying [`SlotMap`].
    #[inline]
    pub fn as_slotmap_mut(&mut self) -> &mut SlotMap<K, V> {
        &mut self.inner
    }
}

impl<K: Key, V> Default for SlotPool<K, V> {
    fn default() -> Self {
        Self::new()
    }
}

impl<K: Key, V> std::ops::Index<K> for SlotPool<K, V> {
    type Output = V;
    #[inline]
    fn index(&self, key: K) -> &V {
        &self.inner[key]
    }
}

impl<K: Key, V> std::ops::IndexMut<K> for SlotPool<K, V> {
    #[inline]
    fn index_mut(&mut self, key: K) -> &mut V {
        &mut self.inner[key]
    }
}

// ── GhostSlotPool ─────────────────────────────────────────────────────────────

/// A [`SlotPool`] whose values are wrapped in `GhostCell<'id, V>`.
///
/// This is the pool type used inside [`crate::domain::mesh::HalfEdgeMesh`].  All
/// mutation requires a `&mut GhostToken<'id>`; all reads require a
/// `&GhostToken<'id>`.  The brand `'id` is bound by [`crate::domain::mesh::with_mesh`]
/// and cannot escape the closure, so the compiler statically prevents mixing
/// tokens from different meshes.
///
/// # Example
///
/// ```rust,ignore
/// use cfd_mesh::{
///     mesh::with_mesh,
///     storage::slotmap_pool::GhostSlotPool,
///     core::index::VertexKey,
///     topology::halfedge::VertexData,
/// };
///
/// with_mesh(|_mesh, mut token| {
///     let mut pool: GhostSlotPool<VertexKey, VertexData> = GhostSlotPool::new();
///     let data = VertexData::new(nalgebra::Point3::origin());
///     let key = pool.insert(cfd_mesh::infrastructure::permission::GhostCell::new(data));
///
///     // Read requires shared token reference
///     let _pos = pool[key].borrow(&token).position;
///
///     // Write requires mutable token reference
///     pool[key].borrow_mut(&mut token).position = nalgebra::Point3::new(1.0, 0.0, 0.0);
/// });
/// ```
pub type GhostSlotPool<'id, K, V> = SlotPool<K, GhostCell<'id, V>>;

// ── Tests ─────────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;
    use slotmap::new_key_type;

    new_key_type! { struct TestKey; }

    #[test]
    fn insert_and_get() {
        let mut pool: SlotPool<TestKey, u32> = SlotPool::new();
        let k = pool.insert(42);
        assert_eq!(pool[k], 42);
        assert_eq!(pool.get(k), Some(&42));
        assert_eq!(pool.len(), 1);
    }

    #[test]
    fn stale_key_returns_none() {
        let mut pool: SlotPool<TestKey, u32> = SlotPool::new();
        let k = pool.insert(99);
        pool.remove(k);
        assert!(pool.get(k).is_none(), "stale key must return None");
        assert_eq!(pool.len(), 0);
    }

    #[test]
    fn contains_key_reflects_liveness() {
        let mut pool: SlotPool<TestKey, u32> = SlotPool::new();
        let k = pool.insert(1);
        assert!(pool.contains_key(k));
        pool.remove(k);
        assert!(!pool.contains_key(k));
    }

    #[test]
    fn iter_yields_all_live() {
        let mut pool: SlotPool<TestKey, u32> = SlotPool::new();
        let k0 = pool.insert(10);
        let k1 = pool.insert(20);
        let k2 = pool.insert(30);
        pool.remove(k1); // k1 is now dead
        let live: Vec<_> = pool.iter().map(|(k, &v)| (k, v)).collect();
        assert_eq!(live.len(), 2);
        assert!(live.iter().any(|&(k, v)| k == k0 && v == 10));
        assert!(live.iter().any(|&(k, v)| k == k2 && v == 30));
    }

    #[test]
    fn clear_empties_pool() {
        let mut pool: SlotPool<TestKey, u32> = SlotPool::new();
        pool.insert(1);
        pool.insert(2);
        pool.clear();
        assert!(pool.is_empty());
    }

    #[test]
    fn ghost_slot_pool_borrow() {
        use crate::infrastructure::permission::{GhostCell, GhostToken};

        new_key_type! { struct Gk; }

        GhostToken::new(|mut token| {
            let mut pool: GhostSlotPool<Gk, u32> = GhostSlotPool::new();
            let k = pool.insert(GhostCell::new(7u32));

            assert_eq!(*pool[k].borrow(&token), 7);
            *pool[k].borrow_mut(&mut token) = 99;
            assert_eq!(*pool[k].borrow(&token), 99);
        });
    }
}
